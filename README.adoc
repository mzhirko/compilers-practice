:doctype: book
:imagesdir: ./images
:nofooter:

= Compilers Course

== Contents
    * <<task1,Task №1>>
    * <<task2,Task №2>>
    * <<task3,Task №3>>
    * <<task4,Task №4>>
    * <<task5,Task №5>>

[#task1]
== Task №1
*Constructing a finite automaton:* +
_**Problem statement: `a^2_(ab)*(c|d)^+`** +

=== 1. Transitions diagram of a finite automaton +
image:finite_state_machine_p1.png[]

=== 2. Determining a finite automaton +
image:finite_state_machine_p2.png[]

=== 3. For the resulting finite state machine, construct a table of states +

[cols="1,1,1,1,1"]
|===
|
|a
|b
|c
|d

|q0
|q1
|
|
|

|q1
|q2
|
|
|

|q2
|q3
|
|q5
|q5

|q3
|
|q4
|
|

|q4
|q3
|
|q5
|q5

|q5
|
|
|q5
|q5

|===

=== 4. Minimization algorithm.

1.Let the set P(0,1,2,3,4,5) be the set of all states. Decompose it into two subsets according to the condition with states (0,1,2,3,4) and (5), where the subset (0,1,2,3,4) contains non-conclusive states, and the subset (5) contains the final state. +
2. The first subset is split into 2 more with states (0,1,3) and (2,4), because for all input symbols the transition by input symbol goes to the final state from the same group. +
3. We split the first subset into 2 with states (0,1) and (3). +
4. We divide the first subset into 2 with states (0) and (1). As a result, we obtained that only one of states 2 and 4 can be kept, e.g. 2. The number of states of the finite automaton is reduced by one. +

image:finite_state_machine_p3.png[]
    
Let us prove that it is minimized: +
{q0,q1,q2,q3}  {q4} +
{q0,q1,q2}  {q3}  {q4} +
{q0}  {q1}  {q2}  {q3}  {q4}

=== 5. We obtained a determined and minimized finite automaton.
Correct strings examples of a finite automaton: +
aacddc +
aaababccdcdc +
aaabccc. +
Examples of incorrect strings: +
bcda +
abacdcd +
abacb.


[#task2]
== Task №2
=== 1. Language description.
<P> ::= <H> (<B>)... +
<H> ::= 'h' ('t' 'i')... +
<B> ::= 'b' (',' 'b')... ';'

=== 2. Constructing grammar following language description.
P -> H +
P -> HG +
G -> BG +
G -> ε +
H -> hN +
N -> tiN +
N -> ε +
B -> bM; +
M -> ,bM +
M -> ε

=== 3. The grammar is context-free (CF) because the characters on the left side are non-terminals and the characters on the right side are terminals or non-terminals.

=== 4. Construct parse trees for the three examples.
.htiti
image::./task2-1.png[]
.htib,b;
image::./task2-2.png[]
.htib,b;b,b,b;
image::./task2-3.png[]

=== 5. The grammar is not left-recursive because there is no rule of the form A -> Aα.
=== 6. The grammar is non-factorized because species rules occur.
A -> aC +
A -> aD +
Left-factorizing the grammar: +
replacing P -> H and P -> HG with P -> HC where C -> G ,  C -> Ɛ. +
The transformed grammar will look as follows:
P -> HC +
C -> G +
C -> ε +
G -> BG +
G -> ε +
H -> hN +
N -> tiN +
N -> ε +
B -> bM; +
M -> ,bM  +
M -> ε +
Since C -> G , C -> Ɛ , and G -> BG , G -> ε , we can ignore C and write it this way: +
P -> HG +
G -> BG +
G -> ε +
H -> hN +
N -> tiN +
N -> ε +
B -> bM; +
M -> ,bM +
M -> ε

=== 7. Using the transformed grammar, construct parsing trees.
.htiti
image::./task2-4.png[]
.htib,b;
image::./task2-5.png[]
.htib,b;b,b,b;
image::./task2-6.png[]

[#task3]
== Task №3
=== 1. Language description.
<P> ::= <H> (<B>)... +
<H> ::= 'h' ('t' 'i')... +
<B> ::= 'b' (',' 'b')... ';'

=== 2. Constructing grammar following language description.
P -> H +
P -> HG +
G -> BG +
G -> ε +
H -> hN +
N -> tiN +
N -> ε +
B -> bM; +
M -> ,bM +
M -> ε

=== 3. The grammar is nonleft-recursive and left-factorized.

=== 4. Let us define the meaning of the FIRST and FOLLOW functions for the developed grammar.
[cols="1,1"]
|===
|*FIRST*             |            *FOLLOW*
|P = {h}             |            P = {$}
|H = {h}             |            H = {b, $}
|N = {t,  ε}         |            N = {b, $}
|M = {, , ε}         |            M = { ; }
|B = {b}             |            B = {b, $}
|G = {b, ε}          |            G = {$}
|===

=== 5. Let's build a predictive analyzer table. 
[width="50%",options="header"]
|====================================================
|        |h     |ti     |b      |,      |;      |$  
|P       |P->HG |       |       |       |       |
|H       |H->hN |       |       |       |       |
|N       |      |N->tiN |N->ε   |       |       |N->ε
|G       |      |       |G->BG  |       |       |G->ε
|B       |      |       |B->bM; |       |       |
|M       |      |       |       |M->,bM |M->ε   |
|====================================================

=== 6. Let's check the correctness of the construction with examples.
==== Correct examples: 

*htib;$* +
P$ +
HG$ +
hNG$ +
NG$ +
tiNG$ +
NG$ +
G$ +
BG$ +
bM;G$ +
M;G$ +
;G$ +
G$ +
$ 

*htitib,b;$* +
P$ +
HG$ +
hNG$ +
NG$ +
tiNG$ +
NG$ +
tiNG$ +
NG$ +
G$ +
BG$ +
bM;G$ +
M;G$ +
,bM;G$ +
M;G$ +
;G$ +
G$ +
$ 

Wrong example:

*hbtib,b;$* +
P$ +
HG$ +
hNG$ +
NG$ +
tiNG$ - mistake, because there is an extra terminal b in the string.

[#task4]
== Task №4

=== Initial grammar for the function declaration:

S -> Aa +
A -> Ac | Bb |  ε +
B -> cB |  ε +

=== 1. Get rid of the left recursion and left-factorize the grammar:

    First we have to get rid of ε-transitions for products with left recursion:

S -> Aa | a +
A -> Ac | Bb | c +
B -> cB | ε +

    Then we have to get rid of the left recursion directly:

S -> Aa | a +
A -> BbA’ | cA’ | Bb | c +
A’ -> cA’ | c +
B -> cB | ε +

    The last step is to left-factorize the grammar:

S -> Aa | a +
A -> BbС | cС +
A’ -> cD +
D - > c| ε +
С -> A’ | ε +
B -> cB | ε

=== 2. Construct the FIRST and FOLLOW functions for the grammar given in the condition:
[cols="1,1"]
|===
|*FIRST*             |            *FOLLOW*
|(S) = {a,с,b}       |           (S)={$}
|(A) = {с,b}         |           (A)={а}
|(B)={с, ε}          |           (B)={b,c,$}
|(C)={c, ε}          |           (C)={$}
|(А’)={с}            |           (А’)={$}
|(D)={c, ε}          |           (D)={$}
|===


=== 3. Building a set of clauses. To do this, number the rules and add a fictitious zero rule. After that the grammar will look like this: 

1. S’->S +
2. S->Аа +
3. S->а +
4. A->BbC +
5. A->cC +
6. A’->cD +
7. D->c +
8. D-> ε +
9. C->A’ +
10. C-> ε +
11. B-> ε +
12. B->cB +

    The set of clauses for a given grammar is represented as: 

I0 = {S’ ->・S, S->・a, S -> ・Aa, A->・cC, A->・BbC, B-> ・, B->・cB} +
I1 = goto(I0, S) = {S’->S・} +
I2 = goto(I0, a) = {S->a・} +
I3 = goto(I0, A) = {S->A・a} +
I4 = goto(I3, a) = {S->Aa・} +
I5 = goto(I0, c) = {A->c・C, C-> ・, C-> ・A’, A’ -> ・cD} +
I6 = goto(I5, C) = {A->cC・} +
I7 = goto(I5, A’) = {C-> A’・} +
I8 = goto(I5, c) = {A’->c・D, D->・c, D->・} +
I9 = goto(I8, D) = {A’->cD・} +
l10 = goto(l8,c) = {D->c・} +
I11 = goto(I0, B) = {A->B・bc} +
I12 = goto(I0, c) = {B->c・B, B->・cB, B->・} +
l13 = goto(l12,B) = {B->cB・}

=== 4. Transition diagram
[width="80%"]
|===
| state | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
|0      |   | S | a | A |   | c |   |   |   |   |    | B  | c  |
|1      |   |   |   |   |   |   |   |   |   |   |    |    |    |
|2      |   |   |   |   |   |   |   |   |   |   |    |    |    |
|3      | s |   |   |   | a |   |   |   |   |   |    |    |    |
|4      |   |   |   |   |   |   |   |   |   |   |    |    |    |
|5      |   |   |   |   |   |   | C | A'|   |   |    |    |    |
|6      |   |   |   |   |   |   |   |   |   |   |    |    |    |
|7      |   |   |   |   |   |   |   |   |   |   |    |    |    |
|8      |   |   |   |   |   |   |   |   |   |   | D  | c  |    |
|9      |   |   |   |   |   |   |   |   |   |   |    |    |    |
|10     |   |   |   |   |   |   |   |   |   |   |    |    |    |
|11     |   |   |   |   |   |   |   |   |   |   |    |    |    |
|12     |   |   |   |   |   |   |   |   |   |   |    |    |    |B
|13     |   |   |   |   |   |   |   |   |   |   |    |    |    | 
|===

=== 5. SLR analyzer table

[width="50%"]
|===
|       |   action                  |   goto
| state | a | b     | c     | $     | A | B | C | S | A'| D 
|0      |s2 |       |s5,s12 |       |3  |11 |   |1  |   |   
|1      |   |       |       |accept |   |   |   |   |   |   
|2      |   |       |       |r2     |   |   |   |   |   |   
|3      |s4 |       |       |       |   |   |   |   |   |   
|4      |   |       |       |r2     |   |   |   |   |   |   
|5      |   |       |s8     |       |   |   |6  |   |7  |   
|6      |r5 |       |       |       |   |   |   |   |   |  
|7      |   |       |       |r9     |   |   |   |   |   |  
|8      |   |       |       |r8     |   |   |   |   |   |9 
|9      |   |       |       |r12    |   |   |   |   |   |
|10     |   |       |       |r7     |   |   |   |   |   |
|11     |   |       |       |       |   |   |   |   |   |
|12     |   |r11    |r11    |r11    |   |13 |   |   |   |
|13     |   |r12    |r12    |r12    |   |   |   |   |   |
|===


[#task5]
== Task №5

=== Task: F2,C3 -> C1

=== Given code:

```int f(int n) { return n * 3 + 1;}``` +
```int main(void) {``` +
```  int d = f (4);``` +
```  return f(5) + d;``` +
```}```

Three-address code. 4s

